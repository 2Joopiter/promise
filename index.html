<!DOCTYPE html>
<html lang="en">

<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Document</title>
</head>

<body>


  <script>
    /*
    ES6부터 promise라는 동기화 처리를 위한 특별한 생성자 함수가 추가
    promise는 일반 인스턴트 객체와는 다르게 생성시점에 값이 정해지는 것이 아닌 상태값 3가지를 품은 상태에서 반환됨
    추후에 그 상대값 변화단계에 따라 각각에 등록된 메서드가 동기적으로 실행되는 방식

    promise의 3가지 상태
    [pending]: 대기. 특정 요청이 들어간 이후 그 요청이 수행될때까지의 대기상태
      // 이후 상태는 수행된 후의 상태
    [fulfilled]: 요청이 성공적으로 수행완료된 상태
    [rejected]: 요청이 실패해서 수행완료된 상태

    promise 인스턴트를 생성해야되는 대표적인 경우
    - 외부 데이터를 가지고 올때까지 다음 업무를 홀딩(holding)시키면서 강제 동기화 처리 해야하는 경우
    - 코드 내부적으로 setTimeout같은 지연시간이 발생하는 코드인 경우 해당 코드가 끝날때까지 홀딩시키면서 동기화 처리해야하는 경우

    promise란 3가지의 내부 상태값을 가지고 있는 객체, 각 객체의 내부 상태변화에 따른 특정 메서드의 호출을 약속받은 객체

    promise 생성자 함수를 통해서 동기화처리할 코드를 통째로 promise객체 인스턴스 형태로 리턴
    이 때 promise 생성자 내부에서 자동으로 res, rej라는 2개의 인수(함수)가 전달되고
    전달받은 코드가 동기적으로 수행되게 하고 싶은 시점에 res를 호출 (then 호출 시점), 
    전달받은 코드를 기반으로 동기적으로 에러를 반환하고 싶은 시점에 rej를 호출 (catch 호출 시점)
    */
    function delay(time) {
      //delay 내부에서 생성되는 promise 인스턴스를 다시 delay 함수 외부로 return
      //delay 함수에 이어서 then을 쓰고 싶은 것이기 때문에(promise를 호출)
      //then을 이어서 호출하기 위해서는 무조건 이전함수가 promise 인스턴스를 반환해야 함
      return new promise((res, rej) => {
        setTimeout(() => {
          console.log('특정 로직이 성공적으로 수행되었을 때 실행할 구문')
          res(); // 해당 생성자로 생성된 인스턴스 객체에는 .then 메서드를 동기적으로 호출할 시점을 정할 수 있음
        }, time)
      })
    }

    delay(3000), then(() => console.log('동기적으로 실행할 코드'))

    // promise 안에 넣어서 무한 callback 지옥을 방지하는거임


  </script>

</body>

</html>